{"ast":null,"code":"import getTokenTypeByToken from \"./getTokenTypeByToken\";\nimport flattenInlineTokens from \"./flattenInlineTokens\";\nimport renderInlineAsText from \"./renderInlineAsText\";\nexport function cleanupTokens(tokens) {\n  tokens = flattenInlineTokens(tokens);\n  tokens.forEach(function (token) {\n    token.type = getTokenTypeByToken(token);\n\n    if (token.type === 'image' || token.type === 'hardbreak') {\n      token.block = true;\n    }\n\n    if (token.type === 'image') {\n      token.attrs[token.attrIndex('alt')][1] = renderInlineAsText(token.children);\n    }\n  });\n  var stack = [];\n  tokens = tokens.reduce(function (acc, token, index) {\n    if (token.type === 'link' && token.nesting === 1) {\n      stack.push(token);\n    } else if (stack.length > 0 && token.type === 'link' && token.nesting === -1) {\n      if (stack.some(function (stackToken) {\n        return stackToken.block;\n      })) {\n        stack[0].type = 'blocklink';\n        stack[0].block = true;\n        token.type = 'blocklink';\n        token.block = true;\n      }\n\n      stack.push(token);\n\n      while (stack.length) {\n        acc.push(stack.shift());\n      }\n    } else if (stack.length > 0) {\n      stack.push(token);\n    } else {\n      acc.push(token);\n    }\n\n    return acc;\n  }, []);\n  return tokens;\n}","map":{"version":3,"sources":["/Users/admin/Documents/GitHub/PMCStorybook/node_modules/react-native-markdown-display/src/lib/util/cleanupTokens.js"],"names":["getTokenTypeByToken","flattenInlineTokens","renderInlineAsText","cleanupTokens","tokens","forEach","token","type","block","attrs","attrIndex","children","stack","reduce","acc","index","nesting","push","length","some","stackToken","shift"],"mappings":"AAAA,OAAOA,mBAAP;AACA,OAAOC,mBAAP;AACA,OAAOC,kBAAP;AAEA,OAAO,SAASC,aAAT,CAAuBC,MAAvB,EAA+B;AACpCA,EAAAA,MAAM,GAAGH,mBAAmB,CAACG,MAAD,CAA5B;AACAA,EAAAA,MAAM,CAACC,OAAP,CAAe,UAACC,KAAD,EAAW;AACxBA,IAAAA,KAAK,CAACC,IAAN,GAAaP,mBAAmB,CAACM,KAAD,CAAhC;;AAGA,QAAIA,KAAK,CAACC,IAAN,KAAe,OAAf,IAA0BD,KAAK,CAACC,IAAN,KAAe,WAA7C,EAA0D;AACxDD,MAAAA,KAAK,CAACE,KAAN,GAAc,IAAd;AACD;;AAGD,QAAIF,KAAK,CAACC,IAAN,KAAe,OAAnB,EAA4B;AAC1BD,MAAAA,KAAK,CAACG,KAAN,CAAYH,KAAK,CAACI,SAAN,CAAgB,KAAhB,CAAZ,EAAoC,CAApC,IAAyCR,kBAAkB,CACzDI,KAAK,CAACK,QADmD,CAA3D;AAGD;AACF,GAdD;AAoBA,MAAMC,KAAK,GAAG,EAAd;AACAR,EAAAA,MAAM,GAAGA,MAAM,CAACS,MAAP,CAAc,UAACC,GAAD,EAAMR,KAAN,EAAaS,KAAb,EAAuB;AAC5C,QAAIT,KAAK,CAACC,IAAN,KAAe,MAAf,IAAyBD,KAAK,CAACU,OAAN,KAAkB,CAA/C,EAAkD;AAChDJ,MAAAA,KAAK,CAACK,IAAN,CAAWX,KAAX;AACD,KAFD,MAEO,IACLM,KAAK,CAACM,MAAN,GAAe,CAAf,IACAZ,KAAK,CAACC,IAAN,KAAe,MADf,IAEAD,KAAK,CAACU,OAAN,KAAkB,CAAC,CAHd,EAIL;AACA,UAAIJ,KAAK,CAACO,IAAN,CAAW,UAACC,UAAD;AAAA,eAAgBA,UAAU,CAACZ,KAA3B;AAAA,OAAX,CAAJ,EAAkD;AAChDI,QAAAA,KAAK,CAAC,CAAD,CAAL,CAASL,IAAT,GAAgB,WAAhB;AACAK,QAAAA,KAAK,CAAC,CAAD,CAAL,CAASJ,KAAT,GAAiB,IAAjB;AACAF,QAAAA,KAAK,CAACC,IAAN,GAAa,WAAb;AACAD,QAAAA,KAAK,CAACE,KAAN,GAAc,IAAd;AACD;;AAEDI,MAAAA,KAAK,CAACK,IAAN,CAAWX,KAAX;;AAEA,aAAOM,KAAK,CAACM,MAAb,EAAqB;AACnBJ,QAAAA,GAAG,CAACG,IAAJ,CAASL,KAAK,CAACS,KAAN,EAAT;AACD;AACF,KAjBM,MAiBA,IAAIT,KAAK,CAACM,MAAN,GAAe,CAAnB,EAAsB;AAC3BN,MAAAA,KAAK,CAACK,IAAN,CAAWX,KAAX;AACD,KAFM,MAEA;AACLQ,MAAAA,GAAG,CAACG,IAAJ,CAASX,KAAT;AACD;;AAED,WAAOQ,GAAP;AACD,GA3BQ,EA2BN,EA3BM,CAAT;AA6BA,SAAOV,MAAP;AACD","sourcesContent":["import getTokenTypeByToken from './getTokenTypeByToken';\nimport flattenInlineTokens from './flattenInlineTokens';\nimport renderInlineAsText from './renderInlineAsText';\n\nexport function cleanupTokens(tokens) {\n  tokens = flattenInlineTokens(tokens);\n  tokens.forEach((token) => {\n    token.type = getTokenTypeByToken(token);\n\n    // set image and hardbreak to block elements\n    if (token.type === 'image' || token.type === 'hardbreak') {\n      token.block = true;\n    }\n\n    // Set img alt text\n    if (token.type === 'image') {\n      token.attrs[token.attrIndex('alt')][1] = renderInlineAsText(\n        token.children,\n      );\n    }\n  });\n\n  /**\n   * changing a link token to a blocklink to fix issue where link tokens with\n   * nested non text tokens breaks component\n   */\n  const stack = [];\n  tokens = tokens.reduce((acc, token, index) => {\n    if (token.type === 'link' && token.nesting === 1) {\n      stack.push(token);\n    } else if (\n      stack.length > 0 &&\n      token.type === 'link' &&\n      token.nesting === -1\n    ) {\n      if (stack.some((stackToken) => stackToken.block)) {\n        stack[0].type = 'blocklink';\n        stack[0].block = true;\n        token.type = 'blocklink';\n        token.block = true;\n      }\n\n      stack.push(token);\n\n      while (stack.length) {\n        acc.push(stack.shift());\n      }\n    } else if (stack.length > 0) {\n      stack.push(token);\n    } else {\n      acc.push(token);\n    }\n\n    return acc;\n  }, []);\n\n  return tokens;\n}\n"]},"metadata":{},"sourceType":"module"}