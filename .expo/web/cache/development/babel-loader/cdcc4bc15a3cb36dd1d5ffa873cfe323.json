{"ast":null,"code":"export default function omitListItemParagraph(tokens) {\n  var depth = null;\n  return tokens.filter(function (token, index) {\n    if (depth !== null) {\n      depth = depth + token.nesting;\n    }\n\n    if (token.type === 'list_item' && token.nesting === 1 && depth === null) {\n      var next = index + 1 in tokens ? tokens[index + 1] : null;\n\n      if (next && next.type === 'paragraph' && next.nesting === 1) {\n        depth = 0;\n        return true;\n      }\n    } else if (token.type === 'paragraph') {\n      if (token.nesting === 1 && depth === 1) {\n        return false;\n      } else if (token.nesting === -1 && depth === 0) {\n        depth = null;\n        return false;\n      }\n    }\n\n    return true;\n  });\n}","map":{"version":3,"sources":["/Users/admin/Documents/GitHub/PMCStorybook/node_modules/react-native-markdown-display/src/lib/util/omitListItemParagraph.js"],"names":["omitListItemParagraph","tokens","depth","filter","token","index","nesting","type","next"],"mappings":"AAAA,eAAe,SAASA,qBAAT,CAA+BC,MAA/B,EAAuC;AAEpD,MAAIC,KAAK,GAAG,IAAZ;AACA,SAAOD,MAAM,CAACE,MAAP,CAAc,UAACC,KAAD,EAAQC,KAAR,EAAkB;AAErC,QAAIH,KAAK,KAAK,IAAd,EAAoB;AAClBA,MAAAA,KAAK,GAAGA,KAAK,GAAGE,KAAK,CAACE,OAAtB;AACD;;AAGD,QAAIF,KAAK,CAACG,IAAN,KAAe,WAAf,IAA8BH,KAAK,CAACE,OAAN,KAAkB,CAAhD,IAAqDJ,KAAK,KAAK,IAAnE,EAAyE;AACvE,UAAMM,IAAI,GAAGH,KAAK,GAAG,CAAR,IAAaJ,MAAb,GAAsBA,MAAM,CAACI,KAAK,GAAG,CAAT,CAA5B,GAA0C,IAAvD;;AACA,UAAIG,IAAI,IAAIA,IAAI,CAACD,IAAL,KAAc,WAAtB,IAAqCC,IAAI,CAACF,OAAL,KAAiB,CAA1D,EAA6D;AAC3DJ,QAAAA,KAAK,GAAG,CAAR;AACA,eAAO,IAAP;AACD;AACF,KAND,MAMO,IAAIE,KAAK,CAACG,IAAN,KAAe,WAAnB,EAAgC;AACrC,UAAIH,KAAK,CAACE,OAAN,KAAkB,CAAlB,IAAuBJ,KAAK,KAAK,CAArC,EAAwC;AAEtC,eAAO,KAAP;AACD,OAHD,MAGO,IAAIE,KAAK,CAACE,OAAN,KAAkB,CAAC,CAAnB,IAAwBJ,KAAK,KAAK,CAAtC,EAAyC;AAE9CA,QAAAA,KAAK,GAAG,IAAR;AACA,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD,GAxBM,CAAP;AAyBD","sourcesContent":["export default function omitListItemParagraph(tokens) {\n  // used to ensure that we remove the correct ending paragraph token\n  let depth = null;\n  return tokens.filter((token, index) => {\n    // update depth if we've already removed a starting paragraph token\n    if (depth !== null) {\n      depth = depth + token.nesting;\n    }\n\n    // check for a list_item token followed by paragraph token (to remove)\n    if (token.type === 'list_item' && token.nesting === 1 && depth === null) {\n      const next = index + 1 in tokens ? tokens[index + 1] : null;\n      if (next && next.type === 'paragraph' && next.nesting === 1) {\n        depth = 0;\n        return true;\n      }\n    } else if (token.type === 'paragraph') {\n      if (token.nesting === 1 && depth === 1) {\n        // remove the paragraph token immediately after the list_item token\n        return false;\n      } else if (token.nesting === -1 && depth === 0) {\n        // remove the ending paragraph token; reset depth\n        depth = null;\n        return false;\n      }\n    }\n    return true;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}